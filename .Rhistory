}
if (type == "matern") {
if (length(params) != 2) {stop("Type 'matern' uses 2 parameters; smoothness and range.")}
nu <- params[1]
l <- params[2]
D <- abs(outer(points, points, "-")) # Distance matrix.
covariance <- Matern(D, range = l, smoothness = nu)
}
if (is.positive.definite(covariance) == FALSE) {
warning("A residual autocorrelation matrix was not positive definite. Shrinking.")
capture.output({covariance <- cov.shrink(covariance)})
}
covariance <- diag(sqrt(variances)) %*% covariance %*% diag(sqrt(variances))
if (sample == TRUE) {
plot(points, t(chol(covariance)) %*% rnorm(length(points)), "l")
}
return(covariance)
}
residual_kernel(rep(1, 100), "squared", 10, sample = TRUE)
residual_kernel(rep(1, 100), sample = TRUE)
residual_kernel(rep(3, 5), "o-u", 10, sample = TRUE)
residual_kernel(rep(3, 5), "o-u", 10, sample = TRUE)
residual_kernel(rep(3, 5), "o-u", 10, sample = TRUE)
residual_kernel(rep(3, 5), "o-u", 10, sample = TRUE)
residual_kernel(rep(3, 5), "o-u", 10, sample = TRUE)
residual_kernel(rep(3, 5), "o-u", 10, sample = TRUE)
residual_kernel(rep(3, 5), "o-u", 10, sample = TRUE)
rnorm(5)
#' export
simulate <- function(X, beta, residual, C = NA) {
Y <- X %*% beta$beta
if (is.na(C) == FALSE) {Y <- Y + C}
epsilon <- matrix(rnorm(NROW(X)*NCOL(beta$beta)), ncol = NROW(X))
epsilon <- epsilon %*% chol(residual)
Y <- Y + epsilon
return(Y)
}
knitr::opts_chunk$set(echo = TRUE)
set.seed(1)
residual <- residual_kernel(rep(3, 5), "o-u", 10, sample = TRUE)
residual
data(table)
data(pca)
library(ULPS)
library(corpcor)
library(ggplot2)
library(fields)
amounts <- rbind(rep(1000, 5)) # A thousand random causal variants at each time point.
variances <- rbind(rep(1, 5)) # At each time point, the variance explained by the polygenic signal is 1.
changes <- rbind(rep(1000, 4)) # Between time points, all causal variants are re-randomized.
shuffles <- rbind(rep(TRUE, 4)) # This does nothing for now since no variants are kept between time points.
poly <- create_effects(table, amounts, variances, changes, shuffles) # Calling the function.
poly
residual
pheno <- simulate(table, poly, residual)
beta$beta
beta[[3]]
beta
poly$beta
NROW(poly$beta)
library(devtools)
library(roxygen2)
document()
knitr::opts_chunk$set(echo = TRUE)
set.seed(1)
library(ULPS)
library(corpcor)
library(ggplot2)
library(fields)
data(table)
data(pca)
amounts <- rbind(rep(1000, 5)) # A thousand random causal variants at each time point.
variances <- rbind(rep(1, 5)) # At each time point, the variance explained by the polygenic signal is 1.
changes <- rbind(rep(1000, 4)) # Between time points, all causal variants are re-randomized.
shuffles <- rbind(rep(TRUE, 4)) # This does nothing for now since no variants are kept between time points.
poly <- create_effects(table, amounts, variances, changes, shuffles) # Calling the function.
simulate()
residual <- residual_kernel(rep(3, 5), "o-u", 10, sample = TRUE)
pheno <- simulate(table, poly, residual)
#' export
simulate <- function(X, beta, residual, C = NA) {
Y <- X %*% beta$beta
if (is.na(C) == FALSE) {Y <- Y + C}
epsilon <- matrix(rnorm(NROW(X)*NCOL(beta$beta)), ncol = NROW(X))
print(NROW(epsilon))
print(NCOL(epsilon))
epsilon <- epsilon %*% chol(residual)
Y <- Y + epsilon
return(Y)
}
pheno <- simulate(table, poly, residual)
#' export
simulate <- function(X, beta, residual, C = NA) {
Y <- X %*% beta$beta
if (is.na(C) == FALSE) {Y <- Y + C}
epsilon <- matrix(rnorm(NROW(X)*NCOL(beta$beta)), nrow = NROW(X))
print(NROW(epsilon))
print(NCOL(epsilon))
epsilon <- epsilon %*% chol(residual)
Y <- Y + epsilon
return(Y)
}
pheno <- simulate(table, poly, residual)
NCOL(Y)
NCOL(pheno)
NROW(pheno)
Y
pheno
library(devtools)
library(roxygen2)
document()
residual_kernel()
library(devtools)
library(roxygen2)
document()
knitr::opts_chunk$set(echo = TRUE)
set.seed(1)
library(ULPS)
library(corpcor)
library(ggplot2)
library(fields)
data(table)
data(pca)
maara <- 20
amounts <- rbind(rep(100, maara))
variances <- rbind(sin(2*pi*seq(1, maara)/maara) + 1.1)
changes <- rbind(rep(100, maara - 1))
shuffles <- rbind(rep(TRUE, maara - 1))
example_gen <- create_effects(table, amounts, variances, changes, shuffles)
NROW(example_gen[[3]])
ncol(example_gen[[3]])
variances <- rbind(cos(2*pi*seq(1, maara)/maara) + 1.1)
example_res <- residual_kernel(variances)
variances <- cos(2*pi*seq(1, maara)/maara) + 1.1
variances
example_res <- residual_kernel(variances)
example_res
example_pheno <- simulate(table, example_gen, example_res)
pca
10*(pca$PC1 + pca$PC2)
length(10*(pca$PC1 + pca$PC2))
ncol(10*(pca$PC1 + pca$PC2), 5)
cbind(10*(pca$PC1 + pca$PC2), 5)
?cbind
rep(10*(pca$PC1 + pca$PC2), 5)
matrix(1,2,3,4, nrow = 2)
matrix(c(1,2,3,4), nrow = 2)
matrix(rep(c(1,2,3), 2), nrow = 2)
matrix(rep(c(1,2,3), 2), ncol = 2)
example_con <- matrix(rep(10*(pca$PC1 + pca$PC2), maara). ncol = maara)
example_con <- matrix(rep(10*(pca$PC1 + pca$PC2), maara), ncol = maara)
example_con[1:10,1:10]
example_pheno <- simulate(table, example_gen, example_res)
example_pheno[1:10,1:10]
example_pheno_confounded <- simulate(table, example_gen, example_res, example_con)
NROW(example_con)
NCOL(example_con)
#' export
simulate <- function(X, beta, residual, C = NA) {
Y <- X %*% beta$beta
if (suppressWarnings(is.na(C)) == FALSE) {Y <- Y + C}
epsilon <- matrix(rnorm(NROW(X)*NCOL(beta$beta)), nrow = NROW(X))
epsilon <- epsilon %*% chol(residual)
Y <- Y + epsilon
return(Y)
}
example_pheno_confounded <- simulate(table, example_gen, example_res, example_con)
is.na(1)
is.na(c(1,5))
#' export
simulate <- function(X, beta, residual, C = NA) {
Y <- X %*% beta$beta
if (suppressWarnings(is.na(C) == FALSE)) {Y <- Y + C}
epsilon <- matrix(rnorm(NROW(X)*NCOL(beta$beta)), nrow = NROW(X))
epsilon <- epsilon %*% chol(residual)
Y <- Y + epsilon
return(Y)
}
example_pheno_confounded <- simulate(table, example_gen, example_res, example_con)
is.na(c(1,1) = FALSE)
is.na(c(1,1) == FALSE)
is.na(c(1,1)) == FALSE
is.na(example_con)
is.na(example_con) == FALSE
if(is.na(example_con) == FALSE)
{print("vittu")}
#' export
simulate <- function(X, beta, residual, C = NA) {
Y <- X %*% beta$beta
suppressWarnings(if (is.na(C) == FALSE) {Y <- Y + C})
epsilon <- matrix(rnorm(NROW(X)*NCOL(beta$beta)), nrow = NROW(X))
epsilon <- epsilon %*% chol(residual)
Y <- Y + epsilon
return(Y)
}
example_pheno_confounded <- simulate(table, example_gen, example_res, example_con)
maara <- 4653
#maara <- 20
amounts <- rbind(rep(100, maara))
variances <- rbind(sin(2*pi*seq(1, maara)/maara) + 1.1)
changes <- rbind(rep(100, maara - 1))
shuffles <- rbind(rep(TRUE, maara - 1))
example_gen <- create_effects(table, amounts, variances, changes, shuffles)
variances <- cos(2*pi*seq(1, maara)/maara) + 1.1
example_res <- residual_kernel(variances)
example_con <- matrix(rep(100*(pca$PC1 + pca$PC2), maara), ncol = maara)
example_pheno <- simulate(table, example_gen, example_res)
example_pheno_confounded <- simulate(table, example_gen, example_res, example_con)
table <- read.table("goats.raw", sep = " ", header = TRUE)
table <- read.table("goats.raw", sep = " ", header = TRUE)
rownames(table) <- table[, 2]
popnames <- table[, 1]
table[, 1:6] <- NULL
for (i in 1:NCOL(table)){
table[is.na(table[, i]), i] <- mean(table[, i], na.rm = TRUE) # Mean imputing NA:s.
}
table[1:10,1:10]
max(table)
for (j in seq(1, NCOL(table))) {
if (max(table[, j]) < 2) print(max(table[, j]))
}
peet <- numeric(0)
for (j in seq(1, NCOL(table))) {
peet[length(peet) + 1] <- mean(table[, j])
}
peet[1:100]
length(peet)
min(peet)
max(peet)
table[1:10,1:10]
peet <- numeric(0)
for (j in seq(1, NCOL(table))) {
peet[length(peet) + 1] <- mean(table[, j])
if (mean(table[, j] == 1) {print(j)}
}
peet <- numeric(0)
for (j in seq(1, NCOL(table))) {
peet[length(peet) + 1] <- mean(table[, j])
if (mean(table[, j]) == 1) {print(j)}
}
table[, 1127]
table[, 1]
mean(table[, 1])
peet <- 0.5*peet
peet[1]
table - peet
table[1:3, 1:3]
peet[1:3]
2*peet[1:3]
(table-peet)[1:3, 1:3]
(table-2*peet)[1:3, 1:3]
NROW(table)
vittu <- matrix(rep(peet, 4653), nrow = 4653)
vittu[1:3, 1:3]
vittu <- matrix(rep(peet, 4653), ncol = 4653)
vittu[1:3, 1:3]
peet[1:3]
vittu <- t(matrix(rep(peet, 4653), ncol = 4653))
peematriisi <- t(matrix(rep(2*peet, 4653), ncol = 4653))
peematriisi[1:3, 1:3]
VanRaden <- (table - peematriisi) %*% t(table - peematriisi)
table - peematriisi
t(table - peematriisi)
VanRaden <- as.matrix(table - peematriisi) %*% t(table - peematriisi)
VanRaden[1:3,1:3]
peet
rbind(peet) %*% cbind(1 - peet)
2*rbind(peet) %*% cbind(1 - peet)
nimittaja <- 2*rbind(peet) %*% cbind(1 - peet)
nimittaja
VanRaden[1:3,1:3]
VanRaden <- VanRaden/nimittaja
nimittaja
as.float(nimittaja)
as.numeric(nimittaja)
VanRaden <- VanRaden/as.numeric(nimittaja)
VanRaden[1:3,1:3]
GRM <- VanRaden
eigen <- eigen(GRM) # Its eigendecomposition.
pca <- data.frame(PC1 = eigen$vectors[, 1], PC2 = eigen$vectors[, 2], population = popnames)
ggplot(pca, aes(x = PC1, y = PC2, fill = population)) +
ggtitle("PCA of the goat data based on chromosomes 1\u20133") +
xlab("PC 1") +
ylab("PC 2") +
theme_classic() +
geom_point(pch = 21, show.legend = FALSE)
TODO
updeittaa kaikki
residuaalin kuvaajat ggplotiksi ja moneksi
dokumentointi
save(example_pheno, file = "example_pheno.RData")
NROW(example_pheno)
ncol(example_pheno)
save(diag(example_pheno), file = "example_pheno.RData")
diag(example_pheno)
example_thin <- diag(example_pheno)
save(diag(example_thin), file = "example_thin.RData")
save(example_thin, file = "example_thin.RData")
save(VanRaden, file = "VanRaden.RData")
example_thin_confounded <- diag(example_pheno_confounded)
data(pca)
save(pca, file = "pca.RData")
sample(4)
sample(4)
sample(4)
sample(4)
jarj <- sample(4653)
jarj
example_pheno_thin <- numeric(0)
example_pheno_confounded_thin <- numeric(0)
jarj <- sample(4653)
example_pheno_thin <- numeric(0)
example_pheno_confounded_thin <- numeric(0)
for (j in seq(1, 4653)) {
example_pheno_thin[j] <- example_pheno[j, jarj[j]]
example_pheno_confounded_thin[j] <- example_pheno_confounded[j, jarj[j]]
}
example_pheno_thin
length(example_pheno_thin)
save(example_pheno_thin, file = "example_pheno_thin.RData")
save(example_pheno_confounded_thin, file = "example_pheno_confounded_thin.RData")
save(jarj, file = "jarj.RData")
jarj
?create_effects
document()
?residual_kernel
?residual_kernel
document()
?residual_kernel
document()
?residual_kernel
#' @param variances A T-vector of residual variance components over time points.
#'                  This forms the diagonal of the finished covariance matrix;
#'                  first a matrix \eqn{K} with unit diagonal elements is created and then all rows and columns are multiplied with the corresponding standard deviation.
#' @param type Determines the kernel function of the Gaussian process. Available options are:
#' * "noise"
#' @param params The parameters
#' * parameter 1 stuff
#' * parameter 2 stuff
#'
#' @export
residual_kernel <- function(variances, type = "noise", params = NA, points = NA, sample = FALSE) {
if (is.na(points) == TRUE) {points <- seq(1, length(variances))}
if (type == "noise") {
if (is.na(params) == FALSE) {stop("Type 'noise' doesn't use parameters.")}
covariance <- diag(length(points))
}
if (type == "squared") {
if (length(params) != 1) {stop("Type 'squared' uses 1 parameter; range.")}
l <- params[1]
D <- abs(outer(points, points, "-")) # Distance matrix.
covariance <- exp(-0.5*(D/l)**2)
}
if (type == "o-u") {
if (length(params) != 1) {stop("Type 'o-u' uses 1 parameter; range.")}
l <- params[1]
D <- abs(outer(points, points, "-")) # Distance matrix.
covariance <- exp(-D/l)
}
if (type == "matern") {
if (length(params) != 2) {stop("Type 'matern' uses 2 parameters; smoothness and range.")}
nu <- params[1]
l <- params[2]
D <- abs(outer(points, points, "-")) # Distance matrix.
covariance <- Matern(D, range = l, smoothness = nu)
}
if (is.positive.definite(covariance) == FALSE) {
warning("A residual autocorrelation matrix was not positive definite. Shrinking.")
capture.output({covariance <- cov.shrink(covariance)})
}
covariance <- diag(sqrt(variances)) %*% covariance %*% diag(sqrt(variances))
if (sample == TRUE) {
plot(points, t(chol(covariance)) %*% rnorm(length(points)), "l")
}
return(covariance)
}
document()
?residual_kernel
document()
?residual_kernel
document()
?residual_kernel
document()
?residual_kernel
document()
?residual_kernel
document()
?residual_kernel
document()
?residual_kernel
install.packages("mathjaxr")
library(mathjaxr)
document()
?residual_kernel
pwd()
setwd("C:/Users/kleppala20/Desktop/ULPS holder/ULPS")
library(ULPS)
?simulate
simulate
?simulate
library(ULPS)
knitr::opts_chunk$set(echo = TRUE)
set.seed(1)
library(corpcor)
library(ggplot2)
library(fields)
data(pca)
pca[1]
pca[2]
PCA[1] %*% c(1,2,3)
pca[1] %*% c(1,2,3)
pca[1] %*% rbind(c(1,2,3))
pca[1]
pca[1,]
pca[, 1]
pca[1]
pca[, 1]
pca[, 1] %*% c(1, 2, 3)
pca[, 1] %*% rbind(c(1, 2, 3))
NROW(pca[, 1] %*% rbind(c(1, 2, 3)))
NCOL(pca[, 1] %*% rbind(c(1, 2, 3)))
pca[, 1] %*% rbind(c(1, 2, 3))
seq(1,4)
seq(1,4, 2)
seq(1,46, 21)
seq(100, 500, 100)
seq(200, 600, 100)
seq(100, 500, 100)
seq(100, 850, 150)
seq(200, 600, 100)
library(devtools)
library(roxygen2)
#library(mathjaxr)
document()
residual <- residual_kernel(rep(3, 5), "o-u", 10, sample = TRUE)
residual <- residual_kernel(rep(3, 5), "o-u", 10, sample = TRUE)
residual <- residual_kernel(rep(3, 5), "o-u", 10, sample = TRUE)
residual <- residual_kernel(rep(3, 5), "o-u", 10, sample = FALSE)
residual <- residual_kernel(rep(3, 5), "o-u", 10, sample = TRUE)
?residual_kernel
?residual_kernel
knitr::opts_chunk$set(echo = TRUE)
set.seed(1)
library(devtools)
library(roxygen2)
#library(mathjaxr)
document()
residual_kernel()
?residual_kernel
?check_explained_variance
?create_effects
library(devtools)
library(roxygen2)
#library(mathjaxr)
document()
library(devtools)
library(roxygen2)
library(mathjaxr)
document()
knitr::opts_chunk$set(echo = TRUE)
set.seed(1)
library(devtools)
library(roxygen2)
document()
library(ULPS)
knitr::opts_chunk$set(echo = TRUE)
set.seed(1)
library(devtools)
library(roxygen2)
document()
library(ULPS)
table[1:10,1:10]
mean(table[,1])
var(table[,1])
var(table[,2])
mean(table[,2])
peet <- numeric(0)
for (j in seq(1, NCOL(table))) {
peet[length(peet) + 1] <- mean(table[, j])
if (mean(table[, j]) == 1) {print(j)}
}
peet <- 0.5*peet
peet
setwd("~/Smooth heritability/Code")
load("~/Smooth heritability/Code/VanRaden.RData")
VanRaden[1:10,1:10]
setwd("C:/Users/kleppala20/PLINK")
table <- read.table("goats.raw", sep = " ", header = TRUE)
rownames(table) <- table[, 2]
popnames <- table[, 1]
table[, 1:6] <- NULL
for (i in 1:NCOL(table)){
table[is.na(table[, i]), i] <- mean(table[, i], na.rm = TRUE) # Mean imputing NA:s.
}
table[1:10,1:10]
counts <- table
save(counts, file = "goat_gounts.RData")
pnorm(0)
pnorm(3)
1-pnorm(3)
2*(1-pnorm(3))
qnorm(1-0.5*0.0027)
unlink('README_cache', recursive = TRUE)
rmarkdown::render("README.Rmd")
jsjvsjvs
install_github()
library(devtoold)
library(devtools)
install_github()
install_github(https://github.com/KalleLeppala/ULPS)
install_github("https://github.com/KalleLeppala/ULPS")
?devtools
